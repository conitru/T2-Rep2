---
title: "Taller 2 - Reproducibilidad y comunicación de datos"
author: "Cristian Sandoval y Constanza Trujillo"
date: "`r Sys.Date()`" #este es un comando para que aparezca la fecha actual
lang: es
format: 
  html:
    title-block-banner: "#ffffff" #el color de fondo del banner
    smooth-scroll: true
    toc: true #tabla de contenido
    toc-depth: 6 #niveles de la tabla de contenido
    toc-location: right #la ubicación de la tabla
    number-sections: true #que enumere las secciones
    number-depth: 6
    code-fold: true #que los códigos se muestren pero ocultos
    bibliography: ref.bib #se refiere a citas en formato BibTeX
    csl: apa-numeric-superscript.csl #Formato de la cita
    theme: cosmo #el tema general, hay muchos tipos
    fig-cap-location: bottom #la ubicación del pie de nota de las figuras/gráficos
    self-contained: false
editor: visual

#    css: styles.css
execute:
  python: true #usar python
  warning: false #que no se muestren los warning
  message: false #que no se muestren otros mensajes
  fig-width: 8 #el ancho de la figura/gráfico
  fig-height: 6 #el alto de la figura/gráfico
---

```{r}
install_and_load <- function(package) {
  if (!require(package, character.only = TRUE)) {
    utils::install.packages(package)
    library(package, character.only = TRUE)
  }
}

# List of packages to be installed and loaded
packages <- c("knitr",
              "kableExtra", 
              "DT", 
              "table1",
            "reticulate",
            "gapminder",
            "latex2exp",
            "tidyverse", 
            "plotly", 
            "sf",
            "dplyr",
            "haven",
            "scales",
            "readxl",
            "stringr",
            "writexl",
            "openxlsx",
            "tidyr",
            "readr",
            "flextable",
            "DT",
            "ggplot2",
            "DiagrammeR",
            "leaflet",
            "geojsonio",
            "httr"
            )

# Apply the function to each package
invisible(capture.output(sapply(packages, install_and_load)))
```

```{css}
body {
  font-family: Arial, sans-serif;
  line-height: 1.5;
}

h1 {
  color: #333333;
}

p {
  text-align: justify;
}

```

# **“El rostro del nuevo electorado: Caracterización de los votantes emergentes en Chile”**

## **Contexto**

Un primer elemento clave para comprender la naturaleza del fenómeno de los nuevos votantes es la naturaleza del sistema electoral chileno, y los cambios profundos que ha experimentado a partir de la ley N°21.524, promulgada en enero de 2023, en donde se restablece el sufragio obligatorio con inscripción automática en Chile, aplicable a todas las elecciones y plebiscitos, exceptuando las elecciones primarias. Este cambio normativo busca incentivar un aumento en la participación ciudadana, el cual efectivamente se ha podido observar en los porcentajes de participación de las elecciones luego de su implementación, con porcentajes por sobre el 80% de participación en todas las elecciones con voto obligatorio de los últimos años.

Si bien este aumento en la participación electoral es un resultado positivo en términos de los objetivos de la legislación, también viene acompañado por determinados desafíos que es necesario que la sociedad chilena y el sistema político aborden, uno de ellos tiene que ver con la comprensión de este nuevo electorado, tanto en su composición sociodemográfica, como también en sus percepciones asociados a la democracia, por ejemplo en sus niveles de información e interés en los procesos electorales, valoración de la democracia, o en su comportamiento electoral en términos de votos válidos e inválidos. Si bien esto último no se encuentra directamente al alcance con la información disponible actualmente, si es posible profundizar en la composición sociodemográfica de este grupo, evaluando sus similitudes y diferencias con otros tipos de electorado más tradicionales.

Adicionalmente, se debe tener en consideración que durante los últimos años se ha generado un ambiente de alta desafección y desconfianza con la política en la sociedad chilena, y este ambiente ha quedado de manifiesto en múltiples estudios de opinión pública. Por ejemplo, la Encuesta Bicentenario del año 2023 muestra un escenario en donde solo un 1% manifestó tener mucha confianza o bastante confianza en los Partidos Políticos y en los Parlamentarios, mientras que un 11% indicó lo mismo respecto del Gobierno (Pontificia Universidad Católica de Chile & GfK Adimark, 2023)[@bicentenario2023]. Este contexto de desconfianza puede influir de manera directa en la participación en los procesos electorales, ya sea que se manifieste directamente como abstención de participar, o bien con otras expresiones como los votos nulos o blancos.

Desde la **teoría de la participación electoral**, Verba y Nie (1972)[@verba1987participation] sostienen que la participación política está influenciada por recursos individuales, incentivos y normas sociales. En este sentido, el voto obligatorio introduce un incentivo coercitivo que disminuye las barreras de entrada al proceso electoral, facilitando la incorporación de nuevos electores. De igual forma, la **teoría de la acción racional** de Downs (1957) [@downs1957economic] refuerza este argumento al plantear que los individuos toman decisiones basadas en un análisis de costo-beneficio, por lo que bajo el voto obligatorio, los costos de no participar aumentan, por lo que se incentiva a una participación más amplia.

Desde otra perspectiva, el fenómeno de los nuevos votantes puede analizarse a través de la **teoría de la socialización política**, la que es fundamental para la formación de actitudes cívicas y una cultura cívica. Almond y Verba (1963)[@almondverba1963] sostienen que el voto obligatorio contribuye a construir una percepción del sufragio no sólo como un derecho, sino también como un deber ciudadano. Esto promueve la formación de patrones cívicos más sólidos en los votantes. Asimismo, la **teoría generacional** de Inglehart (1997)[@inglehart1997] plantea que las experiencias políticas iniciales de los nuevos votantes en contextos de obligatoriedad del voto podrían dar lugar a comportamientos y actitudes diferentes a las de generaciones anteriores, generando cambios en la cultura política del país a largo plazo.

La **reconfiguración del electorado** es otra forma de comprender la relevancia del voto obligatorio. De acuerdo con Lijphart (1997)[@lijphart1997], el voto obligatorio tiende a aumentar la participación electoral general, reduciendo brechas históricas entre grupos socioeconómicos y etarios, e incorporando sectores que tradicionalmente muestran mayores niveles de abstención (como jóvenes y personas con menor nivel educativo). Finalmente, desde una **perspectiva institucional**, North (1990)[@north1990institutions] sostiene que el cambio de las reglas formales, como el cambio al voto obligatorio, generan nuevos incentivos y restricciones que reconfiguran el comportamiento electoral. Esta ley, que implica un cambio normativo, también se presenta como una oportunidad para analizar cómo los nuevos votantes responden a estas transformaciones institucionales, y cómo su participación puede incidir en la legitimidad y representatividad de las elecciones.

## **Objetivos del estudio**

-   Caracterizar a los nuevos votantes que participaron en elecciones generales en Chile desde la implementación del régimen de voto obligatorio

-   Diseñar tipología de tipos de votante en base a su comportamiento electoral

-   Comparar sociodemograficamente entre grupos de votantes según su comportamiento electoral

## **Justificación y metodología**

Los principios de reproducibilidad, replicabilidad y ciencia abierta son esenciales para asegurar la calidad y el impacto de este tipo de estudio. La reproducibilidad (que implica que otros investigadores puedan reproducir el estudio utilizando los mismos datos y métodos) es un principio fundamental de las ciencias sociales, donde fenómenos complejos como la participación electoral requieren metodologías claras que puedan ser verificadas y ampliadas por otros estudios.

En el contexto de este estudio, un factor clave de la reproducibilidad tiene que ver con las diversas fuentes posibles de información sobre la participación electoral de los ciudadanos/as, ya que la fuente oficial de datos electorales (SERVEL), entrega diversos resultados de participación a lo largo de un proceso electoral. Por ejemplo, en sus resultados preliminares inmediatamente finalizada una elección, pero también en resultados oficiales luego de su validación por el TRICEL. La especificación de cuáles son los datos utilizados es fundamental para la reproducibilidad de los resultados, además de que su integración en un único estudio no solo facilita el acceso a la información, sino que permite revisar de forma integral el fenómeno, lo que otorga una visión más precisa y completa del comportamiento electoral.

En tanto, la replicabilidad hace referencia a que los resultados puedan ser validados en contextos diferentes o momentos históricos distintos. Esto ayuda a descubrir variaciones y patrones contextuales que aportan a la teoría y práctica en el análisis de la participación política. En este caso, el fenómeno de las elecciones y sus niveles de participación es una problemática de estudio transversal a todas las democracias, cada una de ellas con sus propias especificidades (por ejemplo, si la inscripción al padrón es automática o voluntaria, si es permanente o transitoria, si el voto es electrónico, si se puede votar anticipadamente, entre muchas otras), por lo que un estudio de este tipo puede resultar fundamental como insumo y experiencia comparada para investigaciones similares en contextos electorales diferentes, ya sea dentro de Chile o en otros países.

El principio de ciencia abierta promueve el acceso a datos, métodos y resultados, lo que permite a investigadores utilizar la información y reinterpretarla. Este principio no sólo democratiza el conocimiento, sino que también contribuye a la transparencia del proceso científico y a la construcción de políticas basadas en evidencia. **Los debates actuales de ciencia de datos (Abbasi et al. 2023)**[@abbasi2023data] se centran en que los esfuerzos científicos deben dirigirse hacia desafíos sociales como la equidad, la justicia y la participación ciudadana. Esto, utilizando metodologías sólidas y accesibles que generen un impacto tangible en la sociedad.

Para poder cumplir con estos principios de ciencia abierta, reproducibilidad y replicabilidad, se generará un modelo dimensional, el cual es una de las técnicas más aceptadas para la presentación de análisis de datos, ya que aborda dos requerimientos clave: **Entregar información entendible para los usuarios y entregar requerimientos de datos de manera rápida (Kimball y Ross, 2013)**[@kimball2013data]. El proyecto actual se plantea bajo estos mismos principios, buscando modelar información de manera simple y fácil de interpretar, utilizando también diversas recomendaciones para la **gestión de datos (Wilson et al, 2017)**[@wilson2017good], tales como la creación de datos fáciles de entender, amigables para el análisis, con múltiples tablas con identificadores únicos para cada registro, entre otros.

## **Arquitectura de datos (ETL)**

**Extract**

En esta fase se recopilan los datos de diversas fuentes relevantes para el estudio. Las principales tareas y fuentes incluyen:

-   Fuentes de Datos:

    -   SERVEL: Datos del padrón electoral, participación por tramo etario, sexo, nacionalidad, comuna y mesa.

        -   Se consideran datos de múltiples elecciones, aunque para el ejercicio sólo se consideran los datos de la elección de Gobernadores Regionales de 2024.

    -   Encuestas públicas:

        -   Encuesta CASEN 2022 (pobreza multidimensional por comuna).

    -   Datos INE: Proyecciones de población año 2024.

```{r, results = 'hide'}
#Las bases de datos se encuentran en enlaces raw de Github para asegurar su reproducibilidad. De todos modos, también se pueden descargar del siguiente link: https://drive.google.com/file/d/1cRmGrrqzyAh4h2uRuKpuNkNenis-y0ir/view?usp=drive_link

#Para el correcto funcionamiento del código, guardar las bases de datos descargadas en una carpeta llamada "data"  dentro de la carpeta "docs" del Github, con los mismos nombres con que vienen del link.

#Base 1: Resultados de Votación. Origen: Servel. Dato Público.
url1 <- "https://raw.githubusercontent.com/conitru/T2-Rep2/ad36ae77d5def450fbe08e277960efb5b31afbce/docs/data2/2024_11_GobernadoresRegionales_Datos_Eleccion.xlsx"

# Descargar el archivo con httr
Temporal1 <- GET(url1)

# Guardar el archivo descargado en un archivo temporal
temp_file1 <- tempfile(fileext = ".xlsx")
writeBin(content(Temporal1, "raw"), temp_file1)

Base_Votacion_Gob2024 <- read_excel(temp_file1, skip = 4)

######Base 2: Datos de Participación por Ciudadano Anonimizado. Origen: Ficticio, creada con la estructura de participación de la elección de Gobernadores de 2024 (Mesa-Comuna-Región), pero con resultados aleatorizados. El proceso de creación de la base de datos aleatorizada se adjuntará como anexo al final del presente informe.

url_zip <- "https://raw.githubusercontent.com/conitru/T2-Rep2/ad36ae77d5def450fbe08e277960efb5b31afbce/docs/data2/Entidad%20Ciudadano%20(Base%20Ficticia).zip"

# Guardar el archivo .zip en un archivo temporal
Temporal2 <- GET(url_zip)
temp_zip <- tempfile(fileext = ".zip")
writeBin(content(Temporal2, "raw"), temp_zip)

# Descomprimir el archivo .zip en una carpeta temporal
temp_dir <- tempfile()
  unzip(temp_zip, exdir = temp_dir)

# Ver los archivos descomprimidos en la carpeta temporal
files <- list.files(temp_dir)
print(files)

# Importar el primer archivo CSV encontrado
file_to_import <- file.path(temp_dir, files[1])  # Asumiendo que el archivo CSV es el primero
Entidad_Ciudadano <- read.csv(file_to_import)  # Leer el archivo CSV

######Base 3: Datos de Entidad Elección. Esta base fue construída por el equipo investigador como un resumen de las elecciones que potencialmente podrían considerarse para el análisis. Para efectos del presente ejercicio, solo se trabajará con datos de la elección de Gobernadores de 2024.

url2 <- "https://raw.githubusercontent.com/conitru/T2-Rep2/ad36ae77d5def450fbe08e277960efb5b31afbce/docs/data2/Base%20Entidad%20Elecci%C3%B3n.xlsx"

# Descargar el archivo con httr
Temporal2 <- GET(url2)

# Guardar el archivo descargado en un archivo temporal
temp_file2 <- tempfile(fileext = ".xlsx")
writeBin(content(Temporal2, "raw"), temp_file2)

Entidad_Elección <- read_excel(temp_file2)


#Base 4: Proyecciones de Población de 2024. Origen: INE. Base de datos del INE con las proyecciones de población, para usarlo como fuente para recuperar el código de la comuna.

url3 <- "https://raw.githubusercontent.com/conitru/T2-Rep2/ad36ae77d5def450fbe08e277960efb5b31afbce/docs/data2/estimaciones-y-proyecciones-2002-2035-comunas%20(1).xlsx"

# Descargar el archivo con httr
Temporal3 <- GET(url3)

# Guardar el archivo descargado en un archivo temporal
temp_file3 <- tempfile(fileext = ".xlsx")
writeBin(content(Temporal3, "raw"), temp_file3)

Proyecciones_INE <- read_excel(temp_file3)

#Base 5: Datos de Pobreza Multidimensional de las Encuesta CASEN 2022. Fuente: Encuesta CASEN 2022. Se utilizará para obtener un dato de porcentaje de pobreza para cada comuna.

url4 <- "https://raw.githubusercontent.com/conitru/T2-Rep2/ad36ae77d5def450fbe08e277960efb5b31afbce/docs/data2/Estimaciones_Indice_Pobreza_Multidimensional_Comunas_2022.xlsx"

# Descargar el archivo con httr
Temporal4 <- GET(url4)

# Guardar el archivo descargado en un archivo temporal
temp_file4 <- tempfile(fileext = ".xlsx")
writeBin(content(Temporal4, "raw"), temp_file4)

CASEN_2022 <- read_excel(temp_file4)

rm(Temporal1,Temporal2,Temporal3,Temporal4,temp_zip, temp_dir,temp_file1,temp_file2,temp_file3,temp_file4,url_zip,url1, url2, url3, url4,file_to_import,files)
```

**Transform**

En esta fase, los datos extraídos se limpian, integran y procesan para generar datasets coherentes y listos para el análisis.

-   Limpieza de Datos:

    -   Eliminar duplicados y registros incompletos.

    -   Estandarización de nombres de variables (edad, género, región, etc.).

    -   Tratamiento de valores nulos y errores tipográficos.

-   Integración de Fuentes:

    -   Unión de bases de datos a través de identificadores comunes (e.j., región, edad).

    -   Generación de nuevas variables derivadas, como:

        -   Clasificación de edad (jóvenes 18-24, adultos jóvenes, etc.).

-   Normalización de Datos:

    -   Aplicación de estructuras tabulares normalizadas para evitar redundancias.

    -   Normalización de datos categóricos (codificación de género)

-   Filtrado de nuevos votantes según criterios: edad, participación electoral.

<!-- -->

-   Cálculo de indicadores como:

    -   Tasa de participación.

    -   Comparación de participación regional.

```{r}
#Parte 1: Base de Entidad_Votación

##Paso 1: Importación (Ya realizado en chunk previo)
##Paso 2: Creación de una llave primaria para cada caso de resultado de votación dentro de la base "Votación", ya que la base de Sevel no viene con una llave primeria creada. Se utilizará un número correlativo desde el 1 al 359162, cubriendo el total de casos de la base de datos. También se crea una llave primaria para la elección (ID_Elección). En este caso, para el ejercicio práctico para el curso de Reproducibilidad, se procederá a trabajar solo con proceso electoral, las elecciones de gobernadores de 2024 (Primera vuelta)

Base_Votacion_Gob2024_2 <- Base_Votacion_Gob2024 %>%
  mutate(ID_Votación = row_number())

Base_Votacion_Gob2024_2 <- Base_Votacion_Gob2024_2 %>%
  mutate(ID_Elección = "Gob_2024")

##Paso 3: Recodificación de los votos en tres categorías "Nulos", "Blancos" y "Válidos"
Base_Votacion_Gob2024_2 <- Base_Votacion_Gob2024_2 %>% 
  mutate(Voto_Recodificado=case_when(
    Nombres=="VOTOS NULOS"~"Nulos",
    Nombres=="VOTOS EN BLANCO"~"Blancos",
    TRUE~"Válidos"
  ))

##Paso 4: Importación de códigos para la variable Comuna (Código del INE). Actualmente la base de SERVEL viene solo con el nombre de la comuna, por lo que se utilizará una fuente oficial (Proyecciones de Población del INE), para recuperar el código de la comuna, y usarlo como llave primaria para identificar la entidad "Comuna".

###Paso 4.1: Importación de la base de datos del INE con las proyecciones de población, para usarlo como fuente para recuperar el código de la comuna (Ya realizado en chunk previo)

###Paso 4.2: Se seleccionan y agrupan en datos únicos solo las variables de interés de la Base "Proyecciones_INE", que correspondería al nombre y código de la comuna como caso único (sin duplicados)
Código_Comunas_INE <- Proyecciones_INE %>% 
  select(Comuna, `Nombre Comuna`) %>% 
  distinct()

rm(Proyecciones_INE) #Se remueve este base, ya que su propósito se cumplió y no volverá a ser utilizada

###Paso 4.3: Se modifica la variable "Comuna" de la base "Base_Votacion_Gob2024_2", para que quede son con mayúscula en su primera letra.

Base_Votacion_Gob2024_2 <- Base_Votacion_Gob2024_2 %>%
  mutate(Comuna = str_to_title(Comuna))

###Paso 4.4: Se cambia el nombre de las variables de la base "Código_Comunas_INE", para factibilizar la comparación con antijoin.

Código_Comunas_INE <- Código_Comunas_INE %>%
  rename(ID_Comuna = Comuna,    
    Comuna = `Nombre Comuna`)

###Paso 4.5: Se crea un nuevo objeto con los nombres de comuna de la "Base_Votacion_Gob2024_2"
Nombres_Comunas_SERVEL <- Base_Votacion_Gob2024_2 %>% 
  select(Comuna) %>% 
  distinct()

###Paso 4.6: Se utiliza antijoin para identificar los casos por comuna que no tienen el mismo texto (tíldes, entre otros).
Diferencias_Comunas1 <- Nombres_Comunas_SERVEL %>%
  anti_join(Código_Comunas_INE, by = "Comuna")

Diferencias_Comunas2 <- Código_Comunas_INE %>%
  anti_join(Nombres_Comunas_SERVEL, by = "Comuna")

#Se identifican 88 comunas con nombres diferentes

###Paso 4.7: Recodificación de las comunas de la base "Base_Votacion_Gob2024_2", para que sus nombres coincidan con la base de Proyecciones del INE.

Base_Votacion_Gob2024_2 <- Base_Votacion_Gob2024_2 %>% 
  mutate(Comuna=case_when(
    Comuna=='Alhue'~'Alhué',
    Comuna=='Alto Biobio'~'Alto Biobío',
    Comuna=='Alto Del Carmen'~'Alto del Carmen',
    Comuna=='Antartica'~'Antártica',
    Comuna=='Aysen'~'Aysén',
    Comuna=='Cabo De Hornos(Ex-Navarino)'~'Cabo de Hornos',
    Comuna=='Calera De Tango'~'Calera de Tango',
    Comuna=='Chaiten'~'Chaitén',
    Comuna=='Chepica'~'Chépica',
    Comuna=='Chillan'~'Chillán',
    Comuna=='Chillan Viejo'~'Chillán Viejo',
    Comuna=='Cochamo'~'Cochamó',
    Comuna=='Colbun'~'Colbún',
    Comuna=='Combarbala'~'Combarbalá',
    Comuna=='Concepcion'~'Concepción',
    Comuna=='Conchali'~'Conchalí',
    Comuna=='Concon'~'Concón',
    Comuna=='Constitucion'~'Constitución',
    Comuna=='Copiapo'~'Copiapó',
    Comuna=='Curacautin'~'Curacautín',
    Comuna=='Curacavi'~'Curacaví',
    Comuna=='Curaco De Velez'~'Curaco de Vélez',
    Comuna=='Curico'~'Curicó',
    Comuna=='Diego De Almagro'~'Diego de Almagro',
    Comuna=='Estacion Central'~'Estación Central',
    Comuna=='Futaleufu'~'Futaleufú',
    Comuna=='Hualaihue'~'Hualaihué',
    Comuna=='Hualañe'~'Hualañé',
    Comuna=='Hualpen'~'Hualpén',
    Comuna=='Isla De Maipo'~'Isla de Maipo',
    Comuna=='Isla De Pascua'~'Isla de Pascua',
    Comuna=='Juan Fernandez'~'Juan Fernández',
    Comuna=='La Union'~'La Unión',
    Comuna=='Licanten'~'Licantén',
    Comuna=='Llay-Llay'~'Llaillay',
    Comuna=='Longavi'~'Longaví',
    Comuna=='Los Alamos'~'Los Álamos',
    Comuna=='Machali'~'Machalí',
    Comuna=='Mafil'~'Máfil',
    Comuna=='Maipu'~'Maipú',
    Comuna=='Marchigue'~'Marchihue',
    Comuna=='Maria Elena'~'María Elena',
    Comuna=='Maria Pinto'~'María Pinto',
    Comuna=='Maullin'~'Maullín',
    Comuna=='Mulchen'~'Mulchén',
    Comuna=='Ñiquen'~'Ñiquén',
    Comuna=="O'higgins"~"O'Higgins",
    Comuna=='Ollague'~'Ollagüe',
    Comuna=='Olmue'~'Olmué',
    Comuna=='Paihuano'~'Paiguano',
    Comuna=='Peñalolen'~'Peñalolén',
    Comuna=='Puchuncavi'~'Puchuncaví',
    Comuna=='Pucon'~'Pucón',
    Comuna=='Puqueldon'~'Puqueldón',
    Comuna=='Puren'~'Purén',
    Comuna=='Queilen'~'Queilén',
    Comuna=='Quellon'~'Quellón',
    Comuna=='Quillon'~'Quillón',
    Comuna=='Quilpue'~'Quilpué',
    Comuna=='Quinta De Tilcoco'~'Quinta de Tilcoco',
    Comuna=='Ranquil'~'Ránquil',
    Comuna=='Requinoa'~'Requínoa',
    Comuna=='Rio Bueno'~'Río Bueno',
    Comuna=='Rio Claro'~'Río Claro',
    Comuna=='Rio Hurtado'~'Río Hurtado',
    Comuna=='Rio Ibañez'~'Río Ibáñez',
    Comuna=='Rio Negro'~'Río Negro',
    Comuna=='Rio Verde'~'Río Verde',
    Comuna=='San Fabian'~'San Fabián',
    Comuna=='San Joaquin'~'San Joaquín',
    Comuna=='San Jose De Maipo'~'San José de Maipo',
    Comuna=='San Juan De La Costa'~'San Juan de la Costa',
    Comuna=='San Nicolas'~'San Nicolás',
    Comuna=='San Pedro De Atacama'~'San Pedro de Atacama',
    Comuna=='San Pedro De La Paz'~'San Pedro de la Paz',
    Comuna=='San Ramon'~'San Ramón',
    Comuna=='Santa Barbara'~'Santa Bárbara',
    Comuna=='Santa Maria'~'Santa María',
    Comuna=='Tirua'~'Tirúa',
    Comuna=='Tolten'~'Toltén',
    Comuna=='Tome'~'Tomé',
    Comuna=='Torres Del Paine'~'Torres del Paine',
    Comuna=='Traiguen'~'Traiguén',
    Comuna=='Trehuaco'~'Treguaco',
    Comuna=='Valparaiso'~'Valparaíso',
    Comuna=='Vichuquen'~'Vichuquén',
    Comuna=='Vilcun'~'Vilcún',
    Comuna=='Viña Del Mar'~'Viña del Mar',
    TRUE~Comuna)
    )

###Paso 4.8: Se repite el antijoin, para verificar si los nombres quedaron iguales.
Nombres_Comunas_SERVEL2 <- Base_Votacion_Gob2024_2 %>% 
  select(Comuna) %>% 
  distinct()

Diferencias_Comunas3 <- Nombres_Comunas_SERVEL2 %>%
  anti_join(Código_Comunas_INE, by = "Comuna")

Diferencias_Comunas4 <- Código_Comunas_INE %>%
  anti_join(Nombres_Comunas_SERVEL2, by = "Comuna")

#Se verifica que hay cero casos con nombres diferentes. Se procede a eliminar los objetos que no seguirán utilizando del environment.

rm(Nombres_Comunas_SERVEL, Nombres_Comunas_SERVEL2, Diferencias_Comunas1, Diferencias_Comunas2, Diferencias_Comunas3, Diferencias_Comunas4)

###Paso 4.9: Se procede a pegar el código de comuna en la base "Base_Votacion_Gob2024_2"
Base_Votacion_Gob2024_2 <- Base_Votacion_Gob2024_2 %>%
  left_join(Código_Comunas_INE, by = "Comuna")

##Paso 5: Creación de una llave primaria "Mesa", con un código único para cada mesa por comuna. Justificción: La base de datos de SERVEL publicada en línea no trae el código único de la mesa, por lo que se procederá a crear un código único combinando la comuna con el número de mesa.

Base_Votacion_Gob2024_2 <- Base_Votacion_Gob2024_2 %>%
  mutate(ID_Mesa = str_c(ID_Comuna, Mesa, sep = "_"))

##Paso 6: Verificación del código Región, para revisar que sus códigos sean los mismos del INE, y cambiar los nombres para que estén completos y con la nomenclatura INE.

Nombres_Regiones_Servel <- Base_Votacion_Gob2024_2 %>% 
  select(`Nro Región`,Región) %>% 
  distinct(`Nro Región`,Región)

#Se verifica que los números asociados a cada región son los mismos en ambas bases. Por lo que solo se procede a modificar el nombre de la variable Nro Región.

Base_Votacion_Gob2024_2 <- Base_Votacion_Gob2024_2 %>%
  rename(ID_Región = `Nro Región`)

Base_Votacion_Gob2024_2 <- Base_Votacion_Gob2024_2 %>% 
  mutate(Región=case_when(
    ID_Región==1~'Tarapacá',
    ID_Región==2~'Antofagasta',
    ID_Región==3~'Atacama',
    ID_Región==4~'Coquimbo',
    ID_Región==5~'Valparaíso',
    ID_Región==6~"Libertador General Bernardo O'Higgins",
    ID_Región==7~'Maule',
    ID_Región==8~'Biobío',
    ID_Región==9~'La Araucanía',
    ID_Región==10~'Los Lagos',
    ID_Región==11~'Aysén del General Carlos Ibáñez del Campo',
    ID_Región==12~'Magallanes y de la Antártica Chilena',
    ID_Región==13~'Metropolitana de Santiago',
    ID_Región==14~'Los Ríos',
    ID_Región==15~'Arica y Parinacota',
    ID_Región==16~'Ñuble'))

#Se eliminan los objetos que ya no se utilizarán
rm(Nombres_Regiones_Servel, Código_Comunas_INE)

##Paso 7: Se cambian los nombres de las varibles "Votos" y "voto_recodificado". Además se crea variable "Tipo_Voto" uniendo los nombres y apellidos de los candidatos cuando estan disponibles.

Base_Votacion_Gob2024_2 <- Base_Votacion_Gob2024_2 %>%
  mutate(Tipo_Voto = case_when(
    !is.na(`Primer apellido`) & !is.na(`Segundo apellido`) ~ paste(Nombres, `Primer apellido`, `Segundo apellido`),
    TRUE ~ Nombres))

Base_Votacion_Gob2024_2 <- Base_Votacion_Gob2024_2 %>%
  rename(Tipo_Voto2 = Voto_Recodificado,
         Cantidad_Votos=Votos)

##Paso 8: Ordenamiento de la base Base_Votacion_Gob2024_2 para que quede como la base normalizada de modelo lógico para la entidad 

Entidad_Votación <- Base_Votacion_Gob2024_2 %>% 
  select(ID_Votación, ID_Elección, ID_Mesa, ID_Comuna, Comuna, ID_Región, Región, Tipo_Voto, Tipo_Voto2, Cantidad_Votos)

######Nota técnica: A partir de este punto, se procedió con el código para crear la base "Entidad Ciudadano". Esta base corresponde a la base de más de 13 millones de votantes de la elección de gobernadores, cada uno asignado a su respectiva mesa, comuna y región. Manteniendo también la estructura de votación en términos de los porcentajes de votos validos, nulos y blancos, los cuales fueron asignados aleatoriamente a la base ficticia. Para revisar el detalle de la construcción de la base ficticia, revisar los anexos de este documento.

#Parte 2: Base de Entidad_Ciudadano: Se carga directamente de la base ficticia creada. Este proceso de importación ya se realizó en un chunk previo.

#Parte 3: Base de Entidad_Mesa (Se contruye a partir de la base de Entidad_Ciudadano).

##Paso 1: Calcular la cantidad de Tipos de Votante para cada mesa. 
Tipología_Mesa <- Entidad_Ciudadano %>%
  group_by(ID_Mesa, Tipo_Votante) %>%          
  summarise(Count = n(), .groups = "drop") %>% 
  pivot_wider(names_from = Tipo_Votante,
              values_from = Count,
              values_fill = 0)  

#Calcular el porcentaje de nuevos votantes para cada mesa
Tipología_Mesa <- Tipología_Mesa %>% 
  mutate(Total_Votantes=(`Nuevo Votante`+`Votante Esporádico`+`Votante Permanente`),
         Porc_Nuevos_Votantes=((`Nuevo Votante`/Total_Votantes)*100),
         Porc_Votantes_Permanentes=((`Votante Permanente`/Total_Votantes)*100),
         Porc_Votantes_Esporádicos=((`Votante Esporádico`/Total_Votantes)*100))


#Se debe elegir un criterio para la clasificación de las mesas categorizadas como "Mesas de Nuevos Votantes". En este punto serán fundamentales los datos reales para poder tomar la decisión, pero dado que en este caso se están utilizando datos ficticios, se tomará como referencia el 30% de mesas con mayor porcentaje de nuevos votantes.

umbral <- quantile(Tipología_Mesa$Porc_Nuevos_Votantes, 0.7)

#El umbral para el corte entre mesas de nuevos votantes es 42.4%.

Tipología_Mesa <- Tipología_Mesa %>%
  mutate(Tipo_Mesa = ifelse(Porc_Nuevos_Votantes >= umbral, 
                       "Mesa de Nuevos Votantes", 
                       "Otro tipo de mesa"))

##Paso 2: Creación de Entidad_Mesa
Entidad_Mesa <- Entidad_Ciudadano %>%
  group_by(ID_Mesa) %>%
  summarise(
    ID_Comuna = first(ID_Comuna),
    Comuna = first(Comuna),
    ID_Región = first(ID_Región),
    Región = first(Región),
    Total_Votantes = n(), # Cuenta total de filas por ID_Mesa
    Total_Blancos = sum(Tipo_Voto2 == "Blancos", na.rm = TRUE), # Total de votos blancos
    Total_Nulos = sum(Tipo_Voto2 == "Nulos", na.rm = TRUE),     # Total de votos nulos
    Total_Validos = sum(Tipo_Voto2 == "Válidos", na.rm = TRUE)  # Total de votos válidos
  )

#Se van a recuperar algunos datos de la base original para agregar a la base de Entidad Mesa, en específico el local de votación y el número de mesa.
#Para ello, primero se crea un data frame con esas variables a recuperar y la llave para conectar las bases.
Local_Mesa <- Base_Votacion_Gob2024_2 %>% 
  select(ID_Mesa, Mesa, Local)

Local_Mesa2 <- Local_Mesa %>%
  group_by(ID_Mesa) %>%
  summarise(
    Mesa = first(Mesa),
    Local = first(Local))

Entidad_Mesa <- Entidad_Mesa %>% 
  left_join(Local_Mesa2, by="ID_Mesa")

Entidad_Mesa <- Entidad_Mesa %>%
  rename(Número_Mesa = Mesa,    
    Local_Votación = Local)

#Finalmente, se agrega la variable nueva "Tipo_Mesa" creada previamente.
Tipología_Mesa2 <- Tipología_Mesa %>% 
  select(ID_Mesa, Tipo_Mesa)

Entidad_Mesa <- Entidad_Mesa %>% 
  left_join(Tipología_Mesa2, by="ID_Mesa")

#Se agrega variable ID_Elección, en este caso solo corresponde a una elección para el ejercicio.
Entidad_Mesa <- Entidad_Mesa %>%
  mutate(ID_Elección = "Gob_2024")

#Se ordenan las variables
Entidad_Mesa <- Entidad_Mesa %>% 
  select(ID_Mesa, Número_Mesa, Local_Votación, ID_Elección, ID_Comuna, Comuna, ID_Región, Región, Total_Validos,Total_Blancos, Total_Nulos, Total_Votantes)

#Se remueven los objetos que ya no se usarán.
rm(Local_Mesa,Local_Mesa2, Tipología_Mesa, Tipología_Mesa2)

#Parte 4: Base de Entidad_Comuna (Se contruye a partir de la base de Entidad_Ciudadano) y los datos de pobreza multidimensional CASEN 2022.

##Paso 1: Importación base de datos CASEN 2022. Este paso de importación ya fue realizado en un chunk anterior.
#Se cambian los nomrbes de algunas variables de la base.
CASEN_2022_2 <- CASEN_2022 %>% 
  select(Código, `Nombre comuna`, `Porcentaje de personas en situación de pobreza multidimensional 2022`) %>% 
  rename(ID_Comuna = Código,
         Comuna=`Nombre comuna`,
         Porc_Pob_Mult=`Porcentaje de personas en situación de pobreza multidimensional 2022`)

##Paso 2: Se crea Base Entidad_Comuna, a partir de la base de datos de Entidad_Ciudadano

Entidad_Comuna <- Entidad_Ciudadano %>% 
    group_by(ID_Comuna) %>%
  summarise(
    Comuna = first(Comuna),
    ID_Región = first(ID_Región),
    Región = first(Región),
    Total_Votantes = n(),
    Total_Nuevos_Votantes = sum(Tipo_Votante == "Nuevo Votante", na.rm = TRUE))

Entidad_Comuna <- Entidad_Comuna %>% 
  mutate(Porc_Nuevos_Votantes=((Total_Nuevos_Votantes/Total_Votantes)*100))

##Paso 3: Se pega el dato de pobreza CASEN en la base de Entidad_Comuna
Entidad_Comuna <- Entidad_Comuna %>% 
  left_join(CASEN_2022_2, by="ID_Comuna")

Entidad_Comuna <- Entidad_Comuna %>% 
  select(ID_Comuna, Comuna.x, ID_Región, Región, Porc_Pob_Mult, Total_Votantes, Total_Nuevos_Votantes, Porc_Nuevos_Votantes) %>% 
  rename(Comuna=Comuna.x,
         Porcentaje_Pobreza_CASEN=Porc_Pob_Mult)

#Se eliminan los objetos que ya no se seguirán utilizandos.
rm(CASEN_2022,CASEN_2022_2, Base_Votacion_Gob2024, Base_Votacion_Gob2024_2)
```

**Load**

En esta fase, los datos transformados se almacenan en un sistema o entorno adecuado para su análisis final.

-   Sistema de almacenamiento:

    -   Github → Herramienta colaborativa para la reproducibilidad

-   Visualización y análisis de resultados

    -   Estadísticos descriptivos

    -   Visualización con ggplot2

## **Modelo Conceptual**

```{r}
#| label: fig-1
#| fig-cap: "Modelo Conceptual"

grViz("
  digraph ModeloConceptual {
    graph [layout = dot, rankdir = LR]
    
    node [shape = rectangle, style = filled, fillcolor = lightgrey, fontname = Arial, fontsize = 10]
    
    // Definición de las tablas y sus atributos
   
   Eleccion [label = <<B>Elección</B><BR ALIGN='LEFT'/><FONT POINT-SIZE='10'>
    ID_Elección (PK)<BR/>
    Nombre_Elección<BR/>
    Tipo_Elección<BR/>
    Tipo_Votación<BR/>
    Fecha</FONT>>]
    
  Ciudadano [label = <<B>Ciudadano</B><BR ALIGN='LEFT'/><FONT POINT-SIZE='10'>
    RUT_ANON (PK)<BR/>
    ID_Comuna (FK)<BR/>
    ID_Region<BR/>
    Sexo<BR/>
    Tramo_etario<BR/>
    Nacionalidad<BR/>
    Afiliacion_partido</FONT>>]
    
    
   Mesa [label = <<B>Mesa</B><BR ALIGN='LEFT'/><FONT POINT-SIZE='10'>
    ID_Mesa (PK)<BR/>
    Número_Mesa<BR/>
    Local_Votación<BR/>
    ID_Elección (FK)<BR/>
    ID_Región<BR/>
    ID_Comuna (FK)<BR/>
    Padron_Mesa</FONT>>]
    
    
  Votacion [shape = diamond, label = <<B>Votación</B><BR ALIGN='LEFT'/><FONT POINT-SIZE='10'>
    ID_Votación (PK)<BR/>
    ID_Elección (FK)<BR/>
    ID_Mesa (FK)<BR/>
    ID_Comuna (FK)<BR/>
    ID_Región<BR/>
    Tipo_Voto<BR/>
    Cantidad_votos</FONT>>]
    
  Comuna [label = <<B>Comuna</B><BR ALIGN='LEFT'/><FONT POINT-SIZE='10'>
    ID_Comuna (PK)<BR/>
    Nombre_Comuna<BR/>
    ID_Región<BR/>
    Porcentaje_Pobreza_CASEN</FONT>>, width = 1.5]
    
    
// Definición de relaciones con posiciones organizadas
    edge [arrowhead = vee, fontsize = 10, color = black]
    Mesa -> Eleccion [label = 'Habilitada para']
    Mesa -> Comuna [label = 'Pertenece a']
    Ciudadano -> Mesa [label = 'Asignado a']
    Ciudadano -> Votacion
    Votacion -> Eleccion
    Votacion -> Mesa [label = 'Ocurre en']
  }
")
```

## **Modelo lógico**

### **Entidad Elección**

```{r}
#| label: tbl-tabla1
#| tbl-cap: "Tabla de Base Entidad Elección"

# Crear tabla interactiva con variables seleccionadas
datatable(
  Entidad_Elección %>% select(ID_Elección, Nombre_Elección, Tipo_Elección, Tipo_Votación, Fecha),
  options = list(
    pageLength = 10,
    autoWidth = TRUE,
    searchHighlight = TRUE
  )
)
```

### **Entidad Ciudadano**

Nota técnica: Solo se presentan 200 casos de la base de datos de la entidad ciudadano, ya que dicha base tiene una cantidad de casos de 13.122.261 casos.

```{r}
Entidad_Ciudadano_200 <- head(Entidad_Ciudadano, 200)
```

```{r}
#| label: tbl-tabla2
#| tbl-cap: "Tabla de Base Entidad Ciudadano"

# Crear tabla interactiva con variables seleccionadas
datatable(
  Entidad_Ciudadano_200 %>% select(ID_Ciudadano, ID_Elección, ID_Mesa, ID_Comuna, Comuna, Comuna, ID_Región, Región, Sexo, Tramo_Etario, Nacionalidad, Afiliación_PP, Tipo_Votante, Tipo_Voto2),
  options = list(
    pageLength = 10,
    autoWidth = TRUE,
    searchHighlight = TRUE
  )
)
```

### **Entidad Mesa**

Nota técnica: Solo se presentan 200 casos de la base de datos de la entidad mesa, ya que dicha base tiene una cantidad de casos de 40.014 casos.

```{r}
Entidad_Mesa_200 <- head(Entidad_Mesa, 200)

```

```{r}
#| label: tbl-tabla3
#| tbl-cap: "Tabla de Base Entidad Mesa"

# Crear tabla interactiva con variables seleccionadas
datatable(
  Entidad_Mesa_200 %>% select(ID_Mesa, Número_Mesa, Local_Votación, ID_Elección, ID_Comuna, Comuna, ID_Región, Región, Total_Validos, Total_Blancos, Total_Nulos, Total_Votantes),
  options = list(
    pageLength = 10,
    autoWidth = TRUE,
    searchHighlight = TRUE
  )
)
```

### **Entidad Comuna**

```{r}
#| label: tbl-tabla4
#| tbl-cap: "Tabla de Base Entidad Comuna"

# Crear tabla interactiva con variables seleccionadas
datatable(
  Entidad_Comuna %>% select(ID_Comuna, Comuna, ID_Región, Región, Porcentaje_Pobreza_CASEN, Total_Votantes, Total_Nuevos_Votantes, Porc_Nuevos_Votantes),
  options = list(
    pageLength = 10,
    autoWidth = TRUE,
    searchHighlight = TRUE
  )
)
```

### **Entidad Votación**

Nota técnica: Solo se presentan 200 casos de la base de datos de la entidad votación, ya que dicha base tiene una cantidad de casos de 359.162 casos.

```{r}
Entidad_Votación_200 <- head(Entidad_Votación, 200)

```

```{r}
#| label: tbl-tabla5
#| tbl-cap: "Tabla de Base Entidad Votación"

# Crear tabla interactiva con variables seleccionadas
datatable(
  Entidad_Votación_200 %>% select(ID_Votación, ID_Elección, ID_Mesa, ID_Comuna, Comuna, ID_Región, Región, Tipo_Voto, Tipo_Voto2, Cantidad_Votos),
  options = list(
    pageLength = 10,
    autoWidth = TRUE,
    searchHighlight = TRUE
  )
)
```

## **Métricas y dimensiones del análisis de datos**

### **Métricas**

```{r}
# Crear la tabla
tabla <- data.frame(
  Categoría = c(
    "Tasa de participación electoral",
    "Clasificación de tipo de votante",
    "Distribución de nuevos votantes por tramo etario",
    "Distribución de nuevos votantes por sexo",
    "Distribución de nuevos votantes por afiliación a partido político",
    "Distribución de nuevos votantes por nacionalidad",
    "Distribución de nuevos votantes según pobreza a nivel comunal"
    ),
  Descripción = c(
    "Porcentaje de votantes habilitados que emitieron su voto.<br><br>

    <b>Fórmula:</b><br>
(Votos Emitidos/Total de votantes habilitados)*100<br><br>

<b>Niveles de análisis (Subconjuntos para estratificar):</b> Este dato se puede presentar agrupado a nivel de las entidades mesa, comuna y elección.<br><br>

<b>Filtros:</b> A nivel de individuo, la información puede filtrarse por sexo, tramo etario y nacionalidad, para poder analizar por segmentos la tasa de participación.",
    
    "En base a las 8 elecciones consideradas para el análisis, se clasificará a cada ciudadano según los siguientes criterios.<br><br>

<b>Votante permanente:</b> 100% de participación en todas las elecciones posibles.<br>
<b>Nuevo votante:</b> 0% de participación en las elecciones de 2020 y 2021 (si es que forma parte del padrón), y >0% en las elecciones de 2022 en adelante.<br>
<b>Votante Esporádico:</b> Todas las demás combinaciones.<br><br>

<b>Fórmula:</b><br> 

Participación elecciones con voto voluntario (P1):<br>

(n de elecciones con voto voluntario/Total de elecciones con voto voluntario)*100<br><br> 

Participación elecciones con voto obligatorio (P2):<br>

(n de elecciones con voto obligatorio/Total de elecciones posibles con voto obligatorio)*100<br><br>

<b>Nota 1:</b> Se consideran como elecciones posibles sólo aquellas desarrolladas entre 2020 y 2024, y que consideren a la totalidad del padrón electoral (no incluye primarias ni 2da vuelta de Gobernadores)<br>

<b>Nota 2:</b> Las personas que cumplieron su edad para votar durante el periodo analizado (2020 a 2024)  serán categorizadas como “votante permanente” si es que participaron en todas sus elecciones posibles, o “votante esporádico” en las demás combinaciones.<br><br>

<b>Niveles de análisis (Subconjuntos para estratificar):</b> La tipología de votantes puede analizarse a nivel total, o agrupada por comuna o mesa.<br><br>

<b>Filtros:</b> A nivel de individuo, la tipología puede filtrarse por datos sociodemográficos (sexo, tramo etario, nacionalidad, afiliación a partido político)",

    "Frecuencias absolutas y relativas de la variable tramo etario según el tipo de votante (Tipo_Votante)<br><br> 

<b>Nivel de análisis (Subconjuntos para estratificar):</b> Total, comunal y por mesa",

    "Frecuencias absolutas y relativas de la variable sexo según el tipo de votante (Tipo_Votante)<br><br> 

<b>Nivel de análisis (Subconjuntos para estratificar):</b> Total, comunal y por mesa",

    "Frecuencias absolutas y relativas de la variable afiliación partido político según el tipo de votante (Tipo_Votante)<br><br>

<b>Nivel de análisis (Subconjuntos para estratificar):</b> Total, comunal y por mesa",

    "Frecuencias absolutas y relativas de la variable nacionalidad según el tipo de votante (Tipo_Votante)<br><br>

<b>Nivel de análisis (Subconjuntos para estratificar):</b> Total, comunal y por mesa",

    "Correlación entre “Porcentaje_Pobreza_CASEN” y “Porcentaje de nuevos votantes” a nivel comunal<br><br>

<b>Nivel de análisis (Subconjuntos para estratificar):</b> Solo comunal."),
 stringsAsFactors = FALSE  # Asegurar que el texto no se trate como factor
)
```

```{r}
#| label: tbl-tabla6
#| tbl-cap: "Métricas"

tabla %>%
  kbl(caption = "MÉTRICAS", escape = FALSE) %>%
  kable_styling(full_width = FALSE) %>%
  column_spec(2, width = "30em")  # Ajustar ancho de la columna Descripción
```

### **Dimensiones**

```{r}
# Crear la tabla
tabla2 <- data.frame(
  Categoría = c(
    "Demográficas",
    "Económicas",
    "Contextuales"
    ),
  Descripción = c(
    "Tramo etario<br>
    Sexo<br>
    Nacionalidad<br>
    Región<br>
    Comuna",
    
    "Porcentaje de pobreza CASEN (Comuna)",

    "Participación en elecciones previas (Trayectoria Electoral)<br>
    Afiliación a partido político<br>
    Tipo de votante<br>
    Tipo de mesa"),
  
 stringsAsFactors = FALSE  # Asegurar que el texto no se trate como factor
)
```

```{r}
#| label: tbl-tabla7
#| tbl-cap: "Dimensiones"

tabla2 %>%
  kbl(caption = "DIMENSIONES", escape = FALSE) %>%
  kable_styling(full_width = FALSE) %>%
  column_spec(2, width = "30em")  # Ajustar ancho de la columna Descripción
```

## **Limitaciones y consideraciones éticas en el uso de los datos**

-   **Disponibilidad de los datos**: La existencia de datos incompletos o inconsistentes puede dificultar un análisis preciso de ciertos subgrupos, como jóvenes o regiones específicas (Ejemplo: Mesas no constituidas o mesas inescrutables).

-   **Falta de acceso a información individualizada:** La imposibilidad de acceder a microdatos individualizados de los votantes (por razones de confidencialidad) limita el nivel de detalle del análisis. Los datos se deben pedir por transparencia, ya que la información disponible de modo abierto en el sitio de Servel no permite individualizar a cada ciudadano/a.

-   **Riesgo de sesgos o interpretaciones equivocadas:** El análisis debe realizarse desde una perspectiva imparcial, evitando sesgos políticos o interpretaciones que puedan tergiversar los resultados. (Por ejemplo, algunas prenociones que se manejan en el debate público son que los nuevos votantes son un grupo de menor nivel educacional, esto habría que mantenerlo un poco de lado y efectivamente ver si los datos respaldan o no este tipo de hipótesis)

-   **Transparencia y reproducibilidad:** Asegurar que el estudio siga los principios de la ciencia abierta y la reproducibilidad, documentando el uso de las fuentes de datos y los métodos analíticos.

## **Análisis preliminar de datos**

En este apartado se presenta el análisis preliminar de los primeros hallazgos del análisis, junto con su representación gráfica e interpretación. Se debe tener en consideración que el análisis se ajusta a los datos ficticios creados producto de la ausencia de información oficial para el análisis.

### **Distribución territorial de los nuevos votantes**

Según lo observado en el mapa de distribución de los nuevos votantes, las comunas que alcanzan un mayor porcentaje de nuevos votantes, los cuales se representan en el mapa con el color amarillo, corresponden a Ollagüe (43,8% de nuevos votantes), Guaitecas (43,76% de nuevos votantes) y O'Higgins (44,4% de nuevos votantes). En tanto, la comuna que muestra un menor porcentaje de nuevos votantes es la comuna de Primavera (37,02% de nuevos votantes). El resto de los resultados según comuna pueden observarse en la @fig-2.

```{r, results = 'hide'}
comunas <- st_read("comunas_simplificado.geojson")

comunas <- comunas %>% 
  rename(ID_Comuna=cod_comuna)

#Se revisa si hay casos no coincidentes por ID_Comuna
no_coincidentes <- Entidad_Comuna %>%
  anti_join(comunas, by = "ID_Comuna")

no_coincidentes2 <- comunas %>%
  anti_join(Entidad_Comuna, by = "ID_Comuna")

Comunas_Mapa <- comunas %>%
  inner_join(Entidad_Comuna, by = "ID_Comuna")

Comunas_Mapa <- Comunas_Mapa %>% filter(codregion != 0) # Eliminamos la región 0 ya que no podremos georeferenciarla, es básicamente un NA (En este caso la comuna de Antartica queda dentro de esta clasificación según los polígonos oficiales descargados)

Comunas_Mapa_wgs84 <- st_transform(Comunas_Mapa, crs = 4326) # Transformamos el mapa a WGS84. Es como "traducir" las coordenadas de un sistema a otro para que todos los elementos del mapa web (base map, polígonos, marcadores, etc.) "hablen el mismo idioma" geográfico.

rm(no_coincidentes,no_coincidentes2, comunas, Comunas_Mapa)
```

```{r}
#| label: fig-2
#| fig-cap: "Mapa Interactivo de Porcentaje de Nuevos Votantes por comuna"

leaflet(data = Comunas_Mapa_wgs84) %>%
  addTiles() %>%  # Agregamos el mapa base
  addPolygons(
    fillColor = ~colorNumeric("plasma", Porc_Nuevos_Votantes)(Porc_Nuevos_Votantes),
    fillOpacity = 0.7,  # Opacidad del relleno
    color = "white",  # Color del borde
    weight = 1,  # Grosor del borde
    popup = ~paste("Comuna:", Comuna.y,
                   "<br>Región:", Región,
                   "<br>% de Pobreza Multidimensional CASEN 2022:", round((Porcentaje_Pobreza_CASEN*100),2), "%",
                   "<br>Total Votantes:", Total_Votantes,
                   "<br>Total Nuevos Votantes:", Total_Nuevos_Votantes,
                   "<br>% de Nuevos Votantes:", round(Porc_Nuevos_Votantes, 2),"%")
  ) %>%
  addLegend(
    pal = colorNumeric("plasma", Comunas_Mapa_wgs84$Porc_Nuevos_Votantes),  # Paleta de colores
    values = Comunas_Mapa_wgs84$Porc_Nuevos_Votantes,  # Valores que se están utilizando para la paleta
    title = "Porcentaje Nuevos Votantes",  # Título de la leyenda
    opacity = 0.7,  # Opacidad de la leyenda
    position = "bottomright"  # Ubicación de la leyenda
  )

```

### **Distribución de los tipos de votantes según sexo**

Los datos muestran que los nuevos votantes tienen una distribución similar por sexo a la observada para los votantes permanentes y esporádicos, con un 52% de mujeres y un 48% de hombres. La distribución para cada uno de los tipos de votantes puede observarse en la @fig-3.

```{r}
#| label: fig-3
#| fig-cap: "Distribución por sexo según tipo de votante"

Entidad_Ciudadano %>%
  group_by(Tipo_Votante, Sexo) %>%
  summarise(Conteo = n(), .groups = "drop") %>%
  group_by(Tipo_Votante) %>%
  mutate(Porcentaje = Conteo / sum(Conteo) * 100) %>%  
  ggplot(aes(x = Tipo_Votante, y = Porcentaje, fill = Sexo)) +
  geom_bar(stat = "identity", position = "fill", color = "black") +  
  coord_flip() + 
  labs(
    title = "Distribución de Sexo por Tipo de Votante",
    x = "Tipo de Votante",
    y = "Proporción",
    fill = "Sexo"
  ) +
  theme_minimal() +  #
  theme(
    legend.position = "right", 
    plot.title = element_text(hjust = 0.5)  # Centrar el título
  ) +
  geom_text(
    aes(label = scales::percent(Porcentaje / 100, accuracy = 0.001)),  
    position = position_fill(vjust = 0.5), 
    color = "white" 
  )

```

### **Distribución de los tipos de votantes según Tramo Etario**

Los datos muetran una distribución de los nuevos votantes marcada por una mayoría de personas adultas (53,57%), mientras que un cuarto de este grupo serían adultos mayores (25,74%), y un quinto serían jóvenes (20,69%). Esta distribución es similar a la observada en los demás grupos de votantes. El detalle de los resultados pueden observarse en la @fig-4.

```{r}
Entidad_Ciudadano2 <- Entidad_Ciudadano %>% 
  mutate(TEDAD=case_when(
    Tramo_Etario=="18-19"~"Joven (18 a 29)",
    Tramo_Etario=="20-29"~"Joven (18 a 29)",
    Tramo_Etario=="30-39"~"Adulto (30 a 59)",
    Tramo_Etario=="40-49"~"Adulto (30 a 59)",
    Tramo_Etario=="50-59"~"Adulto (30 a 59)",
    Tramo_Etario=="60-69"~"Adulto Mayor (60 o más)",
    Tramo_Etario=="70-79"~"Adulto Mayor (60 o más)",
    Tramo_Etario=="80+"~"Adulto Mayor (60 o más)"))
```

```{r}
#| label: fig-4
#| fig-cap: "Distribución por tramo etario según tipo de votante"

Entidad_Ciudadano2 %>%
  group_by(Tipo_Votante, TEDAD) %>%
  summarise(Conteo = n(), .groups = "drop") %>%
  group_by(Tipo_Votante) %>%
  mutate(Porcentaje = Conteo / sum(Conteo) * 100) %>%  
  mutate(TEDAD = factor(TEDAD, levels = c("Adulto Mayor (60 o más)", "Adulto (30 a 59)", "Joven (18 a 29)"))) %>%  # Establecer el orden de TEDAD
  ggplot(aes(x = Tipo_Votante, y = Porcentaje, fill = TEDAD)) +
  geom_bar(stat = "identity", position = "fill", color = "black") +  
  coord_flip() + 
  labs(
    title = "Distribución de Tramo Etario por Tipo de Votante",
    x = "Tipo de Votante",
    y = "Proporción",
    fill = "Tramo Etario"
  ) +
  theme_minimal() +  #
  theme(
    legend.position = "right", 
    plot.title = element_text(hjust = 0.5)  # Centrar el título
  ) +
  geom_text(
    aes(label = scales::percent(Porcentaje / 100, accuracy = 0.01)),  
    position = position_fill(vjust = 0.5), 
    color = "white" 
  )
```
```{r}
rm(Entidad_Ciudadano2)
```

### **Distribución de los tipos de votantes según nacionalidad**

En términos de la nacionalidad de los nuevos votantes, el 96,99% son chilenos, mientras que solo un 3,01% son extranjeros, cifras que no varían de modo relevante en los demás tipos de votantes. El detalle de los resultados pueden observarse en la @fig-5.

```{r}
#| label: fig-5
#| fig-cap: "Distribución por nacionalidad según tipo de votante"

Entidad_Ciudadano %>%
  group_by(Tipo_Votante, Nacionalidad) %>%
  summarise(Conteo = n(), .groups = "drop") %>%
  group_by(Tipo_Votante) %>%
  mutate(Porcentaje = Conteo / sum(Conteo) * 100) %>%  
  ggplot(aes(x = Tipo_Votante, y = Porcentaje, fill = Nacionalidad)) +
  geom_bar(stat = "identity", position = "fill", color = "black") +  
  coord_flip() + 
  labs(
    title = "Distribución de Nacionalidad por Tipo de Votante",
    x = "Tipo de Votante",
    y = "Proporción",
    fill = "Nacionalidad"
  ) +
  theme_minimal() +  #
  theme(
    legend.position = "right", 
    plot.title = element_text(hjust = 0.5)  # Centrar el título
  ) +
  geom_text(
    aes(label = scales::percent(Porcentaje / 100, accuracy = 0.01)),  
    position = position_fill(vjust = 0.5), 
    color = "black" 
  )

```

## **Anexos**

Se adjunta como anexo el código para la creación de la base ficticia "Entidad_Ciudadano". Se debe considerar que el código considera la asignación aleatoria de datos para poder describir variables a las cuales no se tiene acceso al momento de realizar el ejercicio.

Se adjunta este código para poder dejar registro de cómo se construyó la base de datos ficticia. Sin embargo, para los análisis, se decargará la base creada y se cargará de modo independiente, para asegurira la reproducibilidad de los datos, y evitar llegar a resultados diferentes a partir de la aleatorización de los datos.

```{r, eval=FALSE}
#Paso 1: Creación de una estructura de base de datos para la Entidad Ciudadano. Esta estructura se genera a partir de los datos de "Entidad_Votación"
Base_Agrupada <- Entidad_Votación %>%
  group_by(ID_Mesa, Tipo_Voto2, ID_Elección, ID_Comuna, Comuna, ID_Región, Región) %>%
  summarise(Votos_Agrupados = sum(Cantidad_Votos, na.rm = TRUE), .groups = "drop")

#Se crea la llave primaria temporal "ID_Agrupación", que se ocupará para recuperar todos los datos en la base ficticia.
Base_Agrupada <- Base_Agrupada %>% 
   mutate(ID_Agrupación = row_number())
 
distribucion_agrupación <- Base_Agrupada %>%
  mutate(Distribució_Agr=(Votos_Agrupados/sum(Votos_Agrupados)))
  
distribucion_agrupación2 <- distribucion_agrupación %>% 
  select(ID_Agrupación, Distribució_Agr)

#Total de casos que deberá tener la base de datos nueva (ficticia)
total_casos <- 13122261

Base_Ficticia <- distribucion_agrupación2 %>%
  mutate(casos_ficticios = round(Distribució_Agr * total_casos)) %>%
  uncount(casos_ficticios) %>%
  arrange(ID_Agrupación)

#Paso 2: Una vez creada la estructura de la base con el total de casos, se utilizará el ID_Votación como llave para recuperar los resultados y distribución territorial de la base de datos.
#Se crea el ID_Ciudadano, en este caso será un número correlativo de 1 a 13122261.
Base_Ficticia <- Base_Ficticia %>% 
   mutate(ID_Ciudadano = row_number())

#Se recuperan los datos de la base "Base_Ficticia" 
Entidad_Ciudadano <- Base_Ficticia %>%
  left_join(Base_Agrupada, by = "ID_Agrupación")

#Se remueven las bases utilizadas previamente y que ya no tendrán uso, para limpiar el environment.
rm(Base_Agrupada,Base_Ficticia,distribucion_agrupación,distribucion_agrupación2)

#Paso 2.1: Verificación de la base nueva. Se revisarán las distribuciones por mesa y comuna en ambas bases, para ver si los resultados coinciden.

Resumen_Comuna_Ciudadano <- Entidad_Ciudadano %>%
  group_by(Comuna) %>%
  summarise(Cantidad_Casos = n(), .groups = "drop")

# Mostrar el resultado
print(Resumen_Comuna_Ciudadano)

Resumen_Comuna_Votación <- Entidad_Votación %>%
  group_by(Comuna) %>%
  summarise(Cantidad_Casos = sum(Cantidad_Votos))

# Mostrar el resultado
print(Resumen_Comuna_Votación)

#Unir ambas bases
Base_verificación <- Resumen_Comuna_Ciudadano %>% 
  left_join(Resumen_Comuna_Votación, by = "Comuna")

#Se verifica que las dos bases tienen la misma cantidad de casos por comuna, por lo que el ejercicio de creación de una base ficticia se considera exitoso.

#Paso 3: Se asignan de modo aleatorio las variables de caracterización sociodemográfica de la base de datos: Sexo, tramo etario, nacionalidad, afiliación a partido político y tipo de votante. Se utilizará la función sample para esto. 

#- Los porcentajes para distribuir las variables se obtendrán de los datos de descripción de votantes de plebiscito 2023 (Sexo, tramo etario y nacionalidad), que son los últimos datos disponibles de Servel. 
#- En el caso de la afiliación a partido político, se utilizará el dato del padrón electoral en 2023 (2,88% inscrito en partido)
#- Tipo de votante: El diseño del estudio propone la creación de una tipología de 3 variables, AQUI VOY.

#Nota relevante: Este ejercicio va en contra del objetivo principal del estudio, que es la caracterización del grupo de nuevos votantes, sin embargo ante la imposibilidad de obtener los datos reales en los plazos establecidos para el trabajo, se optará por privilegiar los objetivos del curso, que tienen que ver con la reproducibilidad de los datos.

set.seed(123)  # Fijar semilla para reproducibilidad

#Aleatorización de sexo.
Entidad_Ciudadano_2 <- Entidad_Ciudadano %>%
  mutate(Sexo = sample(c("Hombre", "Mujer"), 
                       size = n(), 
                       replace = TRUE, 
                       prob = c(0.48, 0.52)))

table(Entidad_Ciudadano_2$Sexo)

#Aleatorización de Tramo etario.
Entidad_Ciudadano_2 <- Entidad_Ciudadano_2 %>%
  mutate(Tramo_Etario = sample(c("18-19", "20-29", "30-39", "40-49", "50-59", "60-69", "70-79", "80+"), 
                       size = n(), 
                       replace = TRUE, 
                       prob = c(0.0321, 0.1749, 0.1953, 0.1711, 0.1693, 0.1429, 0.0805, 0.0339)))

table(Entidad_Ciudadano_2$Tramo_Etario)

#Aleatorización de Nacionalidad.
Entidad_Ciudadano_2 <- Entidad_Ciudadano_2 %>%
  mutate(Nacionalidad = sample(c("Chilena", "Extranjera"), 
                       size = n(), 
                       replace = TRUE, 
                       prob = c(0.97, 0.03)))

table(Entidad_Ciudadano_2$Nacionalidad)

#Aleatorización de Afiliacion a Partido Político.
Entidad_Ciudadano_2 <- Entidad_Ciudadano_2 %>%
  mutate(Afiliación_PP = sample(c("Sí", "No"), 
                       size = n(), 
                       replace = TRUE, 
                       prob = c(0.0288, 0.9712)))

table(Entidad_Ciudadano_2$Afiliación_PP)

#Aleatorización de Tipo de Votante.
#La categorización de los ciudadanos por tipo de votantes es la principal clasificación requerida para el análisis de los nuevos votantes, y para poder realizarla se requiere de la trayectoria electoral de las personas que conforman el padrón de las elecciones de 2024.
#No obstante, para el ejercicio de este taller, no se cuenta aún con los datos oficiales de las trayectorias electorales, por lo que se generarán de modo aleatorio las clasificaciones de tipo de votante, usando las siguientes proporciones:

#  - Votante Permanente: 35%
#  - Votante Esporádico: 24%
#  - Votante Nuevo: 41%
#  *Datos Ficticios

#Aleatorización de Tipo de Votante.
Entidad_Ciudadano_2 <- Entidad_Ciudadano_2 %>%
  mutate(Tipo_Votante = sample(c("Votante Permanente", "Votante Esporádico","Nuevo Votante"), 
                       size = n(), 
                       replace = TRUE, 
                       prob = c(0.35, 0.24, 0.41)))

table(Entidad_Ciudadano_2$Tipo_Votante)

#Se eliminan algunas variables que no se utilizarán en el análisis.
Entidad_Ciudadano_3 <- Entidad_Ciudadano_2 %>% 
  select(ID_Ciudadano, ID_Elección, ID_Mesa, ID_Comuna, Comuna, ID_Región, Región, Sexo, Tramo_Etario, Nacionalidad, Afiliación_PP, Tipo_Votante, Tipo_Voto2)

#Paso 4: Guardado de la base de datos, la que luego se cargará de modo independiente para asegurar reproducibilidad de los resultados.

#Sacar "#" al write.csv para guardar la base de datos.
#write.csv(Entidad_Ciudadano_3, "Entidad Ciudadano (Base Ficticia).csv", row.names = FALSE)

#Se eliminan objetos que no se seguirán utilizando.
rm(Base_verificación, Resumen_Comuna_Ciudadano,Resumen_Comuna_Votación, Entidad_Ciudadano, Entidad_Ciudadano_2, Entidad_Ciudadano_3)
```

## **Información del Entorno**

Se guarda un archivo sessions_info.txt para describir de modo detallado el entorno de R con el cual se realizó este análisis.

```{r}
writeLines(capture.output(sessionInfo()), "session_info.txt")
```
